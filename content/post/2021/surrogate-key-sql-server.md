---
title: "Surrogate Keys and How to Create Them in SQL Server"
description: "Learn how to create a surrogate key in SQL Server. Understand what a surrogate key is and how it is different from a natural key."
date: 2021-04-22T08:10:10+07:00
image: ""
imageAuthor: ""
imageAuthorUrl: ""
imageSource: ""
imageSourceUrl: ""
tags: ["web development"]
categories: ["technology"]
keywords: ["surrogate key sql","surrogate keys sql","sql surrogate key","sql surrogate keys","natural key sql","sql server surrogate key", "surrogate keys in sql server","surrogate key in sql server"]
---

In the relational database concept, a row must be uniquely identifiable. 
There has to be a column in the table that you can use to identify one row with absolutely no ambiguity. 
This particular field is called the **primary key**.

But what if there aren't any attributes that naturally identify a row? 
In this case, you can create a new column as a substitute for the primary key. 
This type of key is called a **surrogate key**. It will contain made-up values, such as auto-increment or GUID values. 

This article covers the concept of surrogate keys and their differences with natural keys. It also demonstrates how to create surrogate keys in SQL Server. 

## Surrogate Key vs. Natural Key

Talking about natural keys vs. surrogate keys can spark a debate because the topic is controversial for many data professionals.

Anyway, let's take a look at each of them in more detail.

### Surrogate keys

A surrogate key is sometimes called an *artificial key* or *synthetic key*. It simply provides a unique value for each row. And it has no actual meaning other than representing existence.

Typically, surrogate keys use incrementing integer values or GUID values. But they can also contain serial values (combination of string and numbers) or even random values. 

Surrogate keys are generated by the system and, ideally, hidden from use (not shared with any users) because they have no business meaning. 

Let's see an example below. 

Suppose you have to keep track well data in a table. The data contains info about the geographic location and depth of each well, as shown in the following `Well` table:

{{< table "table table-sm table-code w-auto" >}}
| Longitude     | Longitude     | Depth     | 
|--------------:|--------------:|----------:|
| 220           | 140           | 5.6       | 
| 220           | 160           | 5.6       | 
| 220           | 170           | 7.5       | 
| 340           | 170           | 8.2       | 
| 340           | 510           | 9.4       | 
{{</ table >}}

From the table above, you can have two wells that have the same value of longitude, latitude, or depth. 
Thus, you cannot choose the primary key from one of these three columns as they do not uniquely identify the row. 

You'll need to create a surrogate key column, which can be a unique auto-number column. 
And here's an example of an auto-number surrogate column named `WellId` in the table:

{{< table "table table-sm table-code w-auto" >}}
| WellId  | Longitude     | Longitude     | Depth     | 
|---------|--------------:|--------------:|----------:|
| 1       | 220           | 140           | 5.6       | 
| 2       | 220           | 160           | 5.6       | 
| 3       | 220           | 170           | 7.5       | 
| 4       | 340           | 170           | 8.2       | 
| 5       | 340           | 510           | 9.4       | 
{{</ table >}}

### Natural keys

Sometimes there is an attribute in your data that does uniquely identify each row---for example, an SSN column in an `Employee` table. 
The SSN value is naturally unique and will never be duplicated.

{{< table "table table-sm table-code w-auto" >}}
| FirstName  | LastName      | SSN           | Salary    | 
|------------|---------------|---------------|----------:|
| Alex       | Gordon        | 412-85-2000   | 70000     | 
| Bob        | Douglas       | 422-55-2010   | 65000     | 
| Zoe        | Stephenson    | 413-73-2090   | 120000    | 
| Amy        | Harrison      | 412-85-2000   | 80000     | 
| Erika      | William       | 462-71-6000   | 75000     | 
{{</ table >}}

Since a natural key contains info about an entity, they have business meaning and would be presented to users.

Other examples of natural keys: 
*ISBN* for books, *email address* for users, *invoice numbers*, *driver's license number*, and so on.

An interesting thing to note is that a natural key (such as SSN, invoice numbers, etc.) in your database is often a surrogate key in its original database. The value maybe just a series of numbers generated in the database where it was created. They are considered "natural" because of usage in the real world. 

*While there are cases where you have no choice but to create a surrogate key, you may still want to use a surrogate key even when your table has a natural key.*

Let's take a look at the example below. 

Suppose you have an Employee table that has an SSN column that uniquely identifies each row. 
This column is a perfect "natural" candidate for your primary key. 
But then, what if the business grows then hires non-US citizens? 
Not everyone will have an SSN, and thus, this column will not be valid as the primary key anymore. 
On the other hand, surrogate keys make for a stable implementation, and that's why many programmers and architects prefer using them. 

## Surrogate key implementation in SQL Server

Most database management systems have features that allow you to create a surrogate key in your table.
The column name is usually taken from the table name plus a suffix: `Id` or `Key`---examples: `ContactId`, `SupplierKey`, etc. 

In SQL Server, common methods for creating surrogate keys are by using:
* A monotonically increasing number, such as using an identity column.
* A globally unique identifier (GUID) data type.

### Using an IDENTITY column

SQL Server supports an IDENTITY column to perform the auto-increment feature. 
When you insert a new record into a table that has an identity column, the value in this column is increased automatically. 

```sql
-- Creates a table named WellA.
-- WellId will have surrogate values that are auto-number.
CREATE TABLE WellA (
	WellId INT IDENTITY(1,1) PRIMARY KEY,
	Longitude INT,
	Latitude INT,
	Depth DECIMAL(2,1)
);
GO

-- Inserts two rows into WellA table.
INSERT INTO WellA VALUES (220, 140, 5.6);
INSERT INTO WellA VALUES (220, 160, 5.6);
GO

-- Displays the WellA data.
SELECT * FROM WellA;
```

Result:

{{< table "table table-sm table-code w-auto" >}}
| WellId  | Longitude     | Longitude     | Depth     | 
|---------|--------------:|--------------:|----------:|
| 1       | 220           | 140           | 5.6       | 
| 2       | 220           | 160           | 5.6       | 
{{</ table >}}


### Using a GUID column

SQL Server GUID is a 16-byte binary data type. 
Based on how GUIDs are generated, there's nearly impossible that there will ever be any duplication in their values. 
These values are guaranteed to be unique across databases and servers.

In SQL Server databases, GUID values are stored in the UNIQUEIDENTIFIER data type. 
You can generate a GUID value in SQL Server by using the NEWID() function.  

```sql
-- Creates a table named WellB. 
-- WellId will have surrogate values that are GUID.
CREATE TABLE WellB (
	WellId UNIQUEIDENTIFIER PRIMARY KEY, 
	Longitude INT,
	Latitude INT,
	Depth DECIMAL(2,1)
);
GO

-- Inserts two rows into WellB table.
INSERT INTO WellB VALUES (NEWID(), 220, 170, 7.5);
INSERT INTO WellB VALUES (NEWID(), 340, 170, 8.2);
GO

-- Displays the WellB data.
SELECT * FROM WellB;
```

Result:

{{< table "table table-sm table-code w-auto" >}}
| WellId                                     | Longitude     | Longitude     | Depth     | 
|--------------------------------------------|--------------:|--------------:|----------:|
| 9C4923C4-7DDE-4024-9BAB-4E2FD2E252C1       | 220           | 170           | 7.5       | 
| 0D5036DA-A756-4499-BF48-E5E4ABBB548A       | 340           | 170           | 8.2       | 
{{</ table >}}
